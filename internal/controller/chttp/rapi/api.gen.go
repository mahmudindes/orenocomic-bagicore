// Package rapi provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen/v2 version v2.0.0 DO NOT EDIT.
package rapi

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/go-chi/chi/v5"
	"github.com/oapi-codegen/runtime"
)

type contextKey string

const (
	BearerAuthScopes contextKey = "BearerAuth.Scopes"
)

// Comic defines model for Comic.
type Comic struct {
	Chapters  *[]ComicChapter `json:"chapters,omitempty"`
	Code      string          `json:"code"`
	CreatedAt time.Time       `json:"createdAt"`
	ID        uint            `json:"id"`
	Links     *[]Link         `json:"links,omitempty"`
	UpdatedAt *time.Time      `json:"updatedAt"`
}

// ComicChapter defines model for ComicChapter.
type ComicChapter struct {
	Chapter    string     `json:"chapter"`
	CreatedAt  time.Time  `json:"createdAt"`
	ID         uint       `json:"id"`
	Links      *[]Link    `json:"links,omitempty"`
	ReleasedAt time.Time  `json:"releasedAt"`
	UpdatedAt  *time.Time `json:"updatedAt"`
	Version    *string    `json:"version"`
}

// ComicChapterLink defines model for ComicChapterLink.
type ComicChapterLink struct {
	CreatedAt         time.Time  `json:"createdAt"`
	LinkID            uint       `json:"linkID"`
	LinkRelativeURL   string     `json:"linkRelativeURL"`
	LinkWebsiteDomain string     `json:"linkWebsiteDomain"`
	UpdatedAt         *time.Time `json:"updatedAt"`
}

// ComicLink defines model for ComicLink.
type ComicLink struct {
	CreatedAt         time.Time  `json:"createdAt"`
	LinkID            uint       `json:"linkID"`
	LinkRelativeURL   string     `json:"linkRelativeURL"`
	LinkWebsiteDomain string     `json:"linkWebsiteDomain"`
	UpdatedAt         *time.Time `json:"updatedAt"`
}

// Error defines model for Error.
type Error struct {
	Error struct {
		Message string `json:"message"`
		Status  string `json:"status"`
	} `json:"error"`
}

// Language defines model for Language.
type Language struct {
	CreatedAt time.Time  `json:"createdAt"`
	ID        uint       `json:"id"`
	IETF      string     `json:"ietf"`
	Name      string     `json:"name"`
	UpdatedAt *time.Time `json:"updatedAt"`
}

// Link defines model for Link.
type Link struct {
	CreatedAt     time.Time   `json:"createdAt"`
	ID            uint        `json:"id"`
	MachineTL     *bool       `json:"machineTL"`
	RelativeURL   string      `json:"relativeURL"`
	TLLanguages   *[]Language `json:"tlLanguages,omitempty"`
	UpdatedAt     *time.Time  `json:"updatedAt"`
	WebsiteDomain string      `json:"websiteDomain"`
	WebsiteID     uint        `json:"websiteID"`
}

// LinkTLLanguage defines model for LinkTLLanguage.
type LinkTLLanguage struct {
	CreatedAt    time.Time  `json:"createdAt"`
	LanguageID   uint       `json:"languageID"`
	LanguageIETF string     `json:"languageIETF"`
	UpdatedAt    *time.Time `json:"updatedAt"`
}

// NewComic defines model for NewComic.
type NewComic struct {
	Code string `form:"code" json:"code"`
}

// NewComicChapter defines model for NewComicChapter.
type NewComicChapter struct {
	Chapter    string    `form:"chapter" json:"chapter"`
	ReleasedAt time.Time `form:"releasedAt" json:"releasedAt"`
	Version    *string   `form:"version" json:"version"`
}

// NewComicChapterLink defines model for NewComicChapterLink.
type NewComicChapterLink struct {
	LinkID            *uint   `form:"linkID" json:"linkID"`
	LinkRelativeURL   *string `form:"linkRelativeURL" json:"linkRelativeURL"`
	LinkWebsiteDomain *string `form:"linkWebsiteDomain" json:"linkWebsiteDomain"`
}

// NewComicLink defines model for NewComicLink.
type NewComicLink struct {
	LinkID            *uint   `form:"linkID" json:"linkID"`
	LinkRelativeURL   *string `form:"linkRelativeURL" json:"linkRelativeURL"`
	LinkWebsiteDomain *string `form:"linkWebsiteDomain" json:"linkWebsiteDomain"`
}

// NewLanguage defines model for NewLanguage.
type NewLanguage struct {
	IETF string `form:"ietf" json:"ietf"`
	Name string `form:"name" json:"name"`
}

// NewLink defines model for NewLink.
type NewLink struct {
	MachineTL     *bool   `form:"machineTL" json:"machineTL"`
	RelativeURL   string  `form:"relativeURL" json:"relativeURL"`
	WebsiteDomain *string `form:"websiteDomain" json:"websiteDomain"`
	WebsiteID     *uint   `form:"websiteID" json:"websiteID"`
}

// NewLinkTLLanguage defines model for NewLinkTLLanguage.
type NewLinkTLLanguage struct {
	LanguageID   *uint   `form:"languageID" json:"languageID"`
	LanguageIETF *string `form:"languageIETF" json:"languageIETF"`
}

// NewWebsite defines model for NewWebsite.
type NewWebsite struct {
	Domain    string `form:"domain" json:"domain"`
	MachineTL *bool  `form:"machineTL" json:"machineTL"`
	Name      string `form:"name" json:"name"`
}

// NewWebsiteTLLanguage defines model for NewWebsiteTLLanguage.
type NewWebsiteTLLanguage struct {
	LanguageID   *uint   `form:"languageID" json:"languageID"`
	LanguageIETF *string `form:"languageIETF" json:"languageIETF"`
}

// Object defines model for Object.
type Object struct {
	CreatedAt time.Time  `json:"createdAt"`
	ID        uint       `json:"id"`
	UpdatedAt *time.Time `json:"updatedAt"`
}

// SetComic defines model for SetComic.
type SetComic struct {
	Code *string `form:"code" json:"code"`
}

// SetComicChapter defines model for SetComicChapter.
type SetComicChapter struct {
	Chapter    *string    `form:"chapter" json:"chapter"`
	ReleasedAt *time.Time `form:"releasedAt" json:"releasedAt"`
	SetNull    []string   `form:"setNull,omitempty" json:"setNull,omitempty"`
	Version    *string    `form:"version" json:"version"`
}

// SetComicChapterLink defines model for SetComicChapterLink.
type SetComicChapterLink struct {
	LinkID            *uint   `form:"linkID" json:"linkID"`
	LinkRelativeURL   *string `form:"linkRelativeURL" json:"linkRelativeURL"`
	LinkWebsiteDomain *string `form:"linkWebsiteDomain" json:"linkWebsiteDomain"`
}

// SetComicLink defines model for SetComicLink.
type SetComicLink struct {
	LinkID            *uint   `form:"linkID" json:"linkID"`
	LinkRelativeURL   *string `form:"linkRelativeURL" json:"linkRelativeURL"`
	LinkWebsiteDomain *string `form:"linkWebsiteDomain" json:"linkWebsiteDomain"`
}

// SetLanguage defines model for SetLanguage.
type SetLanguage struct {
	IETF *string `form:"ietf" json:"ietf"`
	Name *string `form:"name" json:"name"`
}

// SetLink defines model for SetLink.
type SetLink struct {
	MachineTL     *bool    `form:"machineTL" json:"machineTL"`
	RelativeURL   *string  `form:"relativeURL" json:"relativeURL"`
	SetNull       []string `form:"setNull,omitempty" json:"setNull,omitempty"`
	WebsiteDomain *string  `form:"websiteDomain" json:"websiteDomain"`
	WebsiteID     *uint    `form:"websiteID" json:"websiteID"`
}

// SetLinkTLLanguage defines model for SetLinkTLLanguage.
type SetLinkTLLanguage struct {
	LanguageID   *uint   `form:"languageID" json:"languageID"`
	LanguageIETF *string `form:"languageIETF" json:"languageIETF"`
}

// SetWebsite defines model for SetWebsite.
type SetWebsite struct {
	Domain    *string `form:"domain" json:"domain"`
	MachineTL *bool   `form:"machineTL" json:"machineTL"`
	Name      *string `form:"name" json:"name"`
}

// SetWebsiteTLLanguage defines model for SetWebsiteTLLanguage.
type SetWebsiteTLLanguage struct {
	LanguageID   *uint   `form:"languageID" json:"languageID"`
	LanguageIETF *string `form:"languageIETF" json:"languageIETF"`
}

// Website defines model for Website.
type Website struct {
	CreatedAt   time.Time   `json:"createdAt"`
	Domain      string      `json:"domain"`
	ID          uint        `json:"id"`
	MachineTL   *bool       `json:"machineTL"`
	Name        string      `json:"name"`
	TLLanguages *[]Language `json:"tlLanguages,omitempty"`
	UpdatedAt   *time.Time  `json:"updatedAt"`
}

// WebsiteTLLanguage defines model for WebsiteTLLanguage.
type WebsiteTLLanguage struct {
	CreatedAt    time.Time  `json:"createdAt"`
	LanguageID   uint       `json:"languageID"`
	LanguageIETF string     `json:"languageIETF"`
	UpdatedAt    *time.Time `json:"updatedAt"`
}

// Default defines model for Default.
type Default = Error

// ListComicParams defines parameters for ListComic.
type ListComicParams struct {
	// Page Page number of results.
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// Limit Maximum number of results.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// OrderBy Sort results returned.
	OrderBy *[]string `form:"order_by,omitempty" json:"order_by,omitempty"`
}

// ListComicChapterParams defines parameters for ListComicChapter.
type ListComicChapterParams struct {
	// Page Page number of results.
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// Limit Maximum number of results.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// OrderBy Sort results returned.
	OrderBy *[]string `form:"order_by,omitempty" json:"order_by,omitempty"`
}

// ListLanguageParams defines parameters for ListLanguage.
type ListLanguageParams struct {
	// Page Page number of results.
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// Limit Maximum number of results.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// OrderBy Sort results returned.
	OrderBy *[]string `form:"order_by,omitempty" json:"order_by,omitempty"`
}

// ListLinkParams defines parameters for ListLink.
type ListLinkParams struct {
	// Page Page number of results.
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// Limit Maximum number of results.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// OrderBy Sort results returned.
	OrderBy *[]string `form:"order_by,omitempty" json:"order_by,omitempty"`
}

// ListWebsiteParams defines parameters for ListWebsite.
type ListWebsiteParams struct {
	// Page Page number of results.
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// Limit Maximum number of results.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// OrderBy Sort results returned.
	OrderBy *[]string `form:"order_by,omitempty" json:"order_by,omitempty"`
}

// AddComicJSONRequestBody defines body for AddComic for application/json ContentType.
type AddComicJSONRequestBody = NewComic

// AddComicFormdataRequestBody defines body for AddComic for application/x-www-form-urlencoded ContentType.
type AddComicFormdataRequestBody = NewComic

// UpdateComicJSONRequestBody defines body for UpdateComic for application/json ContentType.
type UpdateComicJSONRequestBody = SetComic

// UpdateComicFormdataRequestBody defines body for UpdateComic for application/x-www-form-urlencoded ContentType.
type UpdateComicFormdataRequestBody = SetComic

// AddComicChapterJSONRequestBody defines body for AddComicChapter for application/json ContentType.
type AddComicChapterJSONRequestBody = NewComicChapter

// AddComicChapterFormdataRequestBody defines body for AddComicChapter for application/x-www-form-urlencoded ContentType.
type AddComicChapterFormdataRequestBody = NewComicChapter

// UpdateComicChapterJSONRequestBody defines body for UpdateComicChapter for application/json ContentType.
type UpdateComicChapterJSONRequestBody = SetComicChapter

// UpdateComicChapterFormdataRequestBody defines body for UpdateComicChapter for application/x-www-form-urlencoded ContentType.
type UpdateComicChapterFormdataRequestBody = SetComicChapter

// AddComicChapterLinkJSONRequestBody defines body for AddComicChapterLink for application/json ContentType.
type AddComicChapterLinkJSONRequestBody = NewComicChapterLink

// AddComicChapterLinkFormdataRequestBody defines body for AddComicChapterLink for application/x-www-form-urlencoded ContentType.
type AddComicChapterLinkFormdataRequestBody = NewComicChapterLink

// UpdateComicChapterLinkJSONRequestBody defines body for UpdateComicChapterLink for application/json ContentType.
type UpdateComicChapterLinkJSONRequestBody = SetComicChapterLink

// UpdateComicChapterLinkFormdataRequestBody defines body for UpdateComicChapterLink for application/x-www-form-urlencoded ContentType.
type UpdateComicChapterLinkFormdataRequestBody = SetComicChapterLink

// AddComicLinkJSONRequestBody defines body for AddComicLink for application/json ContentType.
type AddComicLinkJSONRequestBody = NewComicLink

// AddComicLinkFormdataRequestBody defines body for AddComicLink for application/x-www-form-urlencoded ContentType.
type AddComicLinkFormdataRequestBody = NewComicLink

// UpdateComicLinkJSONRequestBody defines body for UpdateComicLink for application/json ContentType.
type UpdateComicLinkJSONRequestBody = SetComicLink

// UpdateComicLinkFormdataRequestBody defines body for UpdateComicLink for application/x-www-form-urlencoded ContentType.
type UpdateComicLinkFormdataRequestBody = SetComicLink

// AddLanguageJSONRequestBody defines body for AddLanguage for application/json ContentType.
type AddLanguageJSONRequestBody = NewLanguage

// AddLanguageFormdataRequestBody defines body for AddLanguage for application/x-www-form-urlencoded ContentType.
type AddLanguageFormdataRequestBody = NewLanguage

// UpdateLanguageJSONRequestBody defines body for UpdateLanguage for application/json ContentType.
type UpdateLanguageJSONRequestBody = SetLanguage

// UpdateLanguageFormdataRequestBody defines body for UpdateLanguage for application/x-www-form-urlencoded ContentType.
type UpdateLanguageFormdataRequestBody = SetLanguage

// AddLinkJSONRequestBody defines body for AddLink for application/json ContentType.
type AddLinkJSONRequestBody = NewLink

// AddLinkFormdataRequestBody defines body for AddLink for application/x-www-form-urlencoded ContentType.
type AddLinkFormdataRequestBody = NewLink

// UpdateLinkJSONRequestBody defines body for UpdateLink for application/json ContentType.
type UpdateLinkJSONRequestBody = SetLink

// UpdateLinkFormdataRequestBody defines body for UpdateLink for application/x-www-form-urlencoded ContentType.
type UpdateLinkFormdataRequestBody = SetLink

// AddLinkTLLanguageJSONRequestBody defines body for AddLinkTLLanguage for application/json ContentType.
type AddLinkTLLanguageJSONRequestBody = NewLinkTLLanguage

// AddLinkTLLanguageFormdataRequestBody defines body for AddLinkTLLanguage for application/x-www-form-urlencoded ContentType.
type AddLinkTLLanguageFormdataRequestBody = NewLinkTLLanguage

// UpdateLinkTLLanguageJSONRequestBody defines body for UpdateLinkTLLanguage for application/json ContentType.
type UpdateLinkTLLanguageJSONRequestBody = SetLinkTLLanguage

// UpdateLinkTLLanguageFormdataRequestBody defines body for UpdateLinkTLLanguage for application/x-www-form-urlencoded ContentType.
type UpdateLinkTLLanguageFormdataRequestBody = SetLinkTLLanguage

// AddWebsiteJSONRequestBody defines body for AddWebsite for application/json ContentType.
type AddWebsiteJSONRequestBody = NewWebsite

// AddWebsiteFormdataRequestBody defines body for AddWebsite for application/x-www-form-urlencoded ContentType.
type AddWebsiteFormdataRequestBody = NewWebsite

// UpdateWebsiteJSONRequestBody defines body for UpdateWebsite for application/json ContentType.
type UpdateWebsiteJSONRequestBody = SetWebsite

// UpdateWebsiteFormdataRequestBody defines body for UpdateWebsite for application/x-www-form-urlencoded ContentType.
type UpdateWebsiteFormdataRequestBody = SetWebsite

// AddWebsiteTLLanguageJSONRequestBody defines body for AddWebsiteTLLanguage for application/json ContentType.
type AddWebsiteTLLanguageJSONRequestBody = NewWebsiteTLLanguage

// AddWebsiteTLLanguageFormdataRequestBody defines body for AddWebsiteTLLanguage for application/x-www-form-urlencoded ContentType.
type AddWebsiteTLLanguageFormdataRequestBody = NewWebsiteTLLanguage

// UpdateWebsiteTLLanguageJSONRequestBody defines body for UpdateWebsiteTLLanguage for application/json ContentType.
type UpdateWebsiteTLLanguageJSONRequestBody = SetWebsiteTLLanguage

// UpdateWebsiteTLLanguageFormdataRequestBody defines body for UpdateWebsiteTLLanguage for application/x-www-form-urlencoded ContentType.
type UpdateWebsiteTLLanguageFormdataRequestBody = SetWebsiteTLLanguage

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// List comic.
	// (GET /comics)
	ListComic(w http.ResponseWriter, r *http.Request, params ListComicParams)
	// Add comic.
	// (POST /comics)
	AddComic(w http.ResponseWriter, r *http.Request)
	// Delete comic.
	// (DELETE /comics/{code})
	DeleteComic(w http.ResponseWriter, r *http.Request, code string)
	// Get comic.
	// (GET /comics/{code})
	GetComic(w http.ResponseWriter, r *http.Request, code string)
	// Update comic.
	// (PATCH /comics/{code})
	UpdateComic(w http.ResponseWriter, r *http.Request, code string)
	// List comic chapter.
	// (GET /comics/{code}/chapters)
	ListComicChapter(w http.ResponseWriter, r *http.Request, code string, params ListComicChapterParams)
	// Add comic chapter.
	// (POST /comics/{code}/chapters)
	AddComicChapter(w http.ResponseWriter, r *http.Request, code string)
	// Delete comic chapter.
	// (DELETE /comics/{code}/chapters/{cv})
	DeleteComicChapter(w http.ResponseWriter, r *http.Request, code string, cv string)
	// Get comic chapter.
	// (GET /comics/{code}/chapters/{cv})
	GetComicChapter(w http.ResponseWriter, r *http.Request, code string, cv string)
	// Update comic chapter.
	// (PATCH /comics/{code}/chapters/{cv})
	UpdateComicChapter(w http.ResponseWriter, r *http.Request, code string, cv string)
	// Add comic chapter link.
	// (POST /comics/{code}/chapters/{cv}/links)
	AddComicChapterLink(w http.ResponseWriter, r *http.Request, code string, cv string)
	// Delete comic chapter link.
	// (DELETE /comics/{code}/chapters/{cv}/links/{websiteDomain}-{relativeURL})
	DeleteComicChapterLink(w http.ResponseWriter, r *http.Request, code string, cv string, websiteDomain string, relativeURL string)
	// Get comic chapter link.
	// (GET /comics/{code}/chapters/{cv}/links/{websiteDomain}-{relativeURL})
	GetComicChapterLink(w http.ResponseWriter, r *http.Request, code string, cv string, websiteDomain string, relativeURL string)
	// Update comic chapter link.
	// (PATCH /comics/{code}/chapters/{cv}/links/{websiteDomain}-{relativeURL})
	UpdateComicChapterLink(w http.ResponseWriter, r *http.Request, code string, cv string, websiteDomain string, relativeURL string)
	// Add comic link.
	// (POST /comics/{code}/links)
	AddComicLink(w http.ResponseWriter, r *http.Request, code string)
	// Delete comic link.
	// (DELETE /comics/{code}/links/{websiteDomain}-{relativeURL})
	DeleteComicLink(w http.ResponseWriter, r *http.Request, code string, websiteDomain string, relativeURL string)
	// Get comic link.
	// (GET /comics/{code}/links/{websiteDomain}-{relativeURL})
	GetComicLink(w http.ResponseWriter, r *http.Request, code string, websiteDomain string, relativeURL string)
	// Update comic link.
	// (PATCH /comics/{code}/links/{websiteDomain}-{relativeURL})
	UpdateComicLink(w http.ResponseWriter, r *http.Request, code string, websiteDomain string, relativeURL string)
	// List language.
	// (GET /languages)
	ListLanguage(w http.ResponseWriter, r *http.Request, params ListLanguageParams)
	// Add language.
	// (POST /languages)
	AddLanguage(w http.ResponseWriter, r *http.Request)
	// Delete language.
	// (DELETE /languages/{ietf})
	DeleteLanguage(w http.ResponseWriter, r *http.Request, ietf string)
	// Get language.
	// (GET /languages/{ietf})
	GetLanguage(w http.ResponseWriter, r *http.Request, ietf string)
	// Update language.
	// (PATCH /languages/{ietf})
	UpdateLanguage(w http.ResponseWriter, r *http.Request, ietf string)
	// List link.
	// (GET /links)
	ListLink(w http.ResponseWriter, r *http.Request, params ListLinkParams)
	// Add link.
	// (POST /links)
	AddLink(w http.ResponseWriter, r *http.Request)
	// Delete link.
	// (DELETE /links/{websiteDomain}-{relativeURL})
	DeleteLink(w http.ResponseWriter, r *http.Request, websiteDomain string, relativeURL string)
	// Get link.
	// (GET /links/{websiteDomain}-{relativeURL})
	GetLink(w http.ResponseWriter, r *http.Request, websiteDomain string, relativeURL string)
	// Update link.
	// (PATCH /links/{websiteDomain}-{relativeURL})
	UpdateLink(w http.ResponseWriter, r *http.Request, websiteDomain string, relativeURL string)
	// Add link TL language.
	// (POST /links/{websiteDomain}-{relativeURL}/tl-languages)
	AddLinkTLLanguage(w http.ResponseWriter, r *http.Request, websiteDomain string, relativeURL string)
	// Delete link TL language.
	// (DELETE /links/{websiteDomain}-{relativeURL}/tl-languages/{ietf})
	DeleteLinkTLLanguage(w http.ResponseWriter, r *http.Request, websiteDomain string, relativeURL string, ietf string)
	// Get link TL language.
	// (GET /links/{websiteDomain}-{relativeURL}/tl-languages/{ietf})
	GetLinkTLLanguage(w http.ResponseWriter, r *http.Request, websiteDomain string, relativeURL string, ietf string)
	// Update link TL language.
	// (PATCH /links/{websiteDomain}-{relativeURL}/tl-languages/{ietf})
	UpdateLinkTLLanguage(w http.ResponseWriter, r *http.Request, websiteDomain string, relativeURL string, ietf string)
	// List website.
	// (GET /websites)
	ListWebsite(w http.ResponseWriter, r *http.Request, params ListWebsiteParams)
	// Add website.
	// (POST /websites)
	AddWebsite(w http.ResponseWriter, r *http.Request)
	// Delete website.
	// (DELETE /websites/{domain})
	DeleteWebsite(w http.ResponseWriter, r *http.Request, domain string)
	// Get website.
	// (GET /websites/{domain})
	GetWebsite(w http.ResponseWriter, r *http.Request, domain string)
	// Update website.
	// (PATCH /websites/{domain})
	UpdateWebsite(w http.ResponseWriter, r *http.Request, domain string)
	// Add website TL language.
	// (POST /websites/{domain}/tl-languages)
	AddWebsiteTLLanguage(w http.ResponseWriter, r *http.Request, domain string)
	// Delete website TL language.
	// (DELETE /websites/{domain}/tl-languages/{ietf})
	DeleteWebsiteTLLanguage(w http.ResponseWriter, r *http.Request, domain string, ietf string)
	// Get website TL language.
	// (GET /websites/{domain}/tl-languages/{ietf})
	GetWebsiteTLLanguage(w http.ResponseWriter, r *http.Request, domain string, ietf string)
	// Update website TL language.
	// (PATCH /websites/{domain}/tl-languages/{ietf})
	UpdateWebsiteTLLanguage(w http.ResponseWriter, r *http.Request, domain string, ietf string)
}

// Unimplemented server implementation that returns http.StatusNotImplemented for each endpoint.

type Unimplemented struct{}

// List comic.
// (GET /comics)
func (_ Unimplemented) ListComic(w http.ResponseWriter, r *http.Request, params ListComicParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Add comic.
// (POST /comics)
func (_ Unimplemented) AddComic(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Delete comic.
// (DELETE /comics/{code})
func (_ Unimplemented) DeleteComic(w http.ResponseWriter, r *http.Request, code string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get comic.
// (GET /comics/{code})
func (_ Unimplemented) GetComic(w http.ResponseWriter, r *http.Request, code string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Update comic.
// (PATCH /comics/{code})
func (_ Unimplemented) UpdateComic(w http.ResponseWriter, r *http.Request, code string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// List comic chapter.
// (GET /comics/{code}/chapters)
func (_ Unimplemented) ListComicChapter(w http.ResponseWriter, r *http.Request, code string, params ListComicChapterParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Add comic chapter.
// (POST /comics/{code}/chapters)
func (_ Unimplemented) AddComicChapter(w http.ResponseWriter, r *http.Request, code string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Delete comic chapter.
// (DELETE /comics/{code}/chapters/{cv})
func (_ Unimplemented) DeleteComicChapter(w http.ResponseWriter, r *http.Request, code string, cv string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get comic chapter.
// (GET /comics/{code}/chapters/{cv})
func (_ Unimplemented) GetComicChapter(w http.ResponseWriter, r *http.Request, code string, cv string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Update comic chapter.
// (PATCH /comics/{code}/chapters/{cv})
func (_ Unimplemented) UpdateComicChapter(w http.ResponseWriter, r *http.Request, code string, cv string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Add comic chapter link.
// (POST /comics/{code}/chapters/{cv}/links)
func (_ Unimplemented) AddComicChapterLink(w http.ResponseWriter, r *http.Request, code string, cv string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Delete comic chapter link.
// (DELETE /comics/{code}/chapters/{cv}/links/{websiteDomain}-{relativeURL})
func (_ Unimplemented) DeleteComicChapterLink(w http.ResponseWriter, r *http.Request, code string, cv string, websiteDomain string, relativeURL string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get comic chapter link.
// (GET /comics/{code}/chapters/{cv}/links/{websiteDomain}-{relativeURL})
func (_ Unimplemented) GetComicChapterLink(w http.ResponseWriter, r *http.Request, code string, cv string, websiteDomain string, relativeURL string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Update comic chapter link.
// (PATCH /comics/{code}/chapters/{cv}/links/{websiteDomain}-{relativeURL})
func (_ Unimplemented) UpdateComicChapterLink(w http.ResponseWriter, r *http.Request, code string, cv string, websiteDomain string, relativeURL string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Add comic link.
// (POST /comics/{code}/links)
func (_ Unimplemented) AddComicLink(w http.ResponseWriter, r *http.Request, code string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Delete comic link.
// (DELETE /comics/{code}/links/{websiteDomain}-{relativeURL})
func (_ Unimplemented) DeleteComicLink(w http.ResponseWriter, r *http.Request, code string, websiteDomain string, relativeURL string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get comic link.
// (GET /comics/{code}/links/{websiteDomain}-{relativeURL})
func (_ Unimplemented) GetComicLink(w http.ResponseWriter, r *http.Request, code string, websiteDomain string, relativeURL string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Update comic link.
// (PATCH /comics/{code}/links/{websiteDomain}-{relativeURL})
func (_ Unimplemented) UpdateComicLink(w http.ResponseWriter, r *http.Request, code string, websiteDomain string, relativeURL string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// List language.
// (GET /languages)
func (_ Unimplemented) ListLanguage(w http.ResponseWriter, r *http.Request, params ListLanguageParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Add language.
// (POST /languages)
func (_ Unimplemented) AddLanguage(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Delete language.
// (DELETE /languages/{ietf})
func (_ Unimplemented) DeleteLanguage(w http.ResponseWriter, r *http.Request, ietf string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get language.
// (GET /languages/{ietf})
func (_ Unimplemented) GetLanguage(w http.ResponseWriter, r *http.Request, ietf string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Update language.
// (PATCH /languages/{ietf})
func (_ Unimplemented) UpdateLanguage(w http.ResponseWriter, r *http.Request, ietf string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// List link.
// (GET /links)
func (_ Unimplemented) ListLink(w http.ResponseWriter, r *http.Request, params ListLinkParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Add link.
// (POST /links)
func (_ Unimplemented) AddLink(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Delete link.
// (DELETE /links/{websiteDomain}-{relativeURL})
func (_ Unimplemented) DeleteLink(w http.ResponseWriter, r *http.Request, websiteDomain string, relativeURL string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get link.
// (GET /links/{websiteDomain}-{relativeURL})
func (_ Unimplemented) GetLink(w http.ResponseWriter, r *http.Request, websiteDomain string, relativeURL string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Update link.
// (PATCH /links/{websiteDomain}-{relativeURL})
func (_ Unimplemented) UpdateLink(w http.ResponseWriter, r *http.Request, websiteDomain string, relativeURL string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Add link TL language.
// (POST /links/{websiteDomain}-{relativeURL}/tl-languages)
func (_ Unimplemented) AddLinkTLLanguage(w http.ResponseWriter, r *http.Request, websiteDomain string, relativeURL string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Delete link TL language.
// (DELETE /links/{websiteDomain}-{relativeURL}/tl-languages/{ietf})
func (_ Unimplemented) DeleteLinkTLLanguage(w http.ResponseWriter, r *http.Request, websiteDomain string, relativeURL string, ietf string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get link TL language.
// (GET /links/{websiteDomain}-{relativeURL}/tl-languages/{ietf})
func (_ Unimplemented) GetLinkTLLanguage(w http.ResponseWriter, r *http.Request, websiteDomain string, relativeURL string, ietf string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Update link TL language.
// (PATCH /links/{websiteDomain}-{relativeURL}/tl-languages/{ietf})
func (_ Unimplemented) UpdateLinkTLLanguage(w http.ResponseWriter, r *http.Request, websiteDomain string, relativeURL string, ietf string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// List website.
// (GET /websites)
func (_ Unimplemented) ListWebsite(w http.ResponseWriter, r *http.Request, params ListWebsiteParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Add website.
// (POST /websites)
func (_ Unimplemented) AddWebsite(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Delete website.
// (DELETE /websites/{domain})
func (_ Unimplemented) DeleteWebsite(w http.ResponseWriter, r *http.Request, domain string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get website.
// (GET /websites/{domain})
func (_ Unimplemented) GetWebsite(w http.ResponseWriter, r *http.Request, domain string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Update website.
// (PATCH /websites/{domain})
func (_ Unimplemented) UpdateWebsite(w http.ResponseWriter, r *http.Request, domain string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Add website TL language.
// (POST /websites/{domain}/tl-languages)
func (_ Unimplemented) AddWebsiteTLLanguage(w http.ResponseWriter, r *http.Request, domain string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Delete website TL language.
// (DELETE /websites/{domain}/tl-languages/{ietf})
func (_ Unimplemented) DeleteWebsiteTLLanguage(w http.ResponseWriter, r *http.Request, domain string, ietf string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get website TL language.
// (GET /websites/{domain}/tl-languages/{ietf})
func (_ Unimplemented) GetWebsiteTLLanguage(w http.ResponseWriter, r *http.Request, domain string, ietf string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Update website TL language.
// (PATCH /websites/{domain}/tl-languages/{ietf})
func (_ Unimplemented) UpdateWebsiteTLLanguage(w http.ResponseWriter, r *http.Request, domain string, ietf string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandlerFunc   func(w http.ResponseWriter, r *http.Request, err error)
}

type MiddlewareFunc func(http.Handler) http.Handler

// ListComic operation middleware
func (siw *ServerInterfaceWrapper) ListComic(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params ListComicParams

	// ------------- Optional query parameter "page" -------------

	err = runtime.BindQueryParameter("form", true, false, "page", r.URL.Query(), &params.Page)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "page", Err: err})
		return
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "limit", Err: err})
		return
	}

	// ------------- Optional query parameter "order_by" -------------

	err = runtime.BindQueryParameter("form", true, false, "order_by", r.URL.Query(), &params.OrderBy)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "order_by", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListComic(w, r, params)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// AddComic operation middleware
func (siw *ServerInterfaceWrapper) AddComic(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AddComic(w, r)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// DeleteComic operation middleware
func (siw *ServerInterfaceWrapper) DeleteComic(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "code" -------------
	var code string

	err = runtime.BindStyledParameterWithLocation("simple", false, "code", runtime.ParamLocationPath, chi.URLParam(r, "code"), &code)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "code", Err: err})
		return
	}

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteComic(w, r, code)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetComic operation middleware
func (siw *ServerInterfaceWrapper) GetComic(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "code" -------------
	var code string

	err = runtime.BindStyledParameterWithLocation("simple", false, "code", runtime.ParamLocationPath, chi.URLParam(r, "code"), &code)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "code", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetComic(w, r, code)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// UpdateComic operation middleware
func (siw *ServerInterfaceWrapper) UpdateComic(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "code" -------------
	var code string

	err = runtime.BindStyledParameterWithLocation("simple", false, "code", runtime.ParamLocationPath, chi.URLParam(r, "code"), &code)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "code", Err: err})
		return
	}

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UpdateComic(w, r, code)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// ListComicChapter operation middleware
func (siw *ServerInterfaceWrapper) ListComicChapter(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "code" -------------
	var code string

	err = runtime.BindStyledParameterWithLocation("simple", false, "code", runtime.ParamLocationPath, chi.URLParam(r, "code"), &code)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "code", Err: err})
		return
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params ListComicChapterParams

	// ------------- Optional query parameter "page" -------------

	err = runtime.BindQueryParameter("form", true, false, "page", r.URL.Query(), &params.Page)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "page", Err: err})
		return
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "limit", Err: err})
		return
	}

	// ------------- Optional query parameter "order_by" -------------

	err = runtime.BindQueryParameter("form", true, false, "order_by", r.URL.Query(), &params.OrderBy)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "order_by", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListComicChapter(w, r, code, params)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// AddComicChapter operation middleware
func (siw *ServerInterfaceWrapper) AddComicChapter(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "code" -------------
	var code string

	err = runtime.BindStyledParameterWithLocation("simple", false, "code", runtime.ParamLocationPath, chi.URLParam(r, "code"), &code)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "code", Err: err})
		return
	}

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AddComicChapter(w, r, code)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// DeleteComicChapter operation middleware
func (siw *ServerInterfaceWrapper) DeleteComicChapter(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "code" -------------
	var code string

	err = runtime.BindStyledParameterWithLocation("simple", false, "code", runtime.ParamLocationPath, chi.URLParam(r, "code"), &code)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "code", Err: err})
		return
	}

	// ------------- Path parameter "cv" -------------
	var cv string

	err = runtime.BindStyledParameterWithLocation("simple", false, "cv", runtime.ParamLocationPath, chi.URLParam(r, "cv"), &cv)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "cv", Err: err})
		return
	}

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteComicChapter(w, r, code, cv)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetComicChapter operation middleware
func (siw *ServerInterfaceWrapper) GetComicChapter(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "code" -------------
	var code string

	err = runtime.BindStyledParameterWithLocation("simple", false, "code", runtime.ParamLocationPath, chi.URLParam(r, "code"), &code)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "code", Err: err})
		return
	}

	// ------------- Path parameter "cv" -------------
	var cv string

	err = runtime.BindStyledParameterWithLocation("simple", false, "cv", runtime.ParamLocationPath, chi.URLParam(r, "cv"), &cv)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "cv", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetComicChapter(w, r, code, cv)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// UpdateComicChapter operation middleware
func (siw *ServerInterfaceWrapper) UpdateComicChapter(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "code" -------------
	var code string

	err = runtime.BindStyledParameterWithLocation("simple", false, "code", runtime.ParamLocationPath, chi.URLParam(r, "code"), &code)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "code", Err: err})
		return
	}

	// ------------- Path parameter "cv" -------------
	var cv string

	err = runtime.BindStyledParameterWithLocation("simple", false, "cv", runtime.ParamLocationPath, chi.URLParam(r, "cv"), &cv)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "cv", Err: err})
		return
	}

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UpdateComicChapter(w, r, code, cv)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// AddComicChapterLink operation middleware
func (siw *ServerInterfaceWrapper) AddComicChapterLink(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "code" -------------
	var code string

	err = runtime.BindStyledParameterWithLocation("simple", false, "code", runtime.ParamLocationPath, chi.URLParam(r, "code"), &code)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "code", Err: err})
		return
	}

	// ------------- Path parameter "cv" -------------
	var cv string

	err = runtime.BindStyledParameterWithLocation("simple", false, "cv", runtime.ParamLocationPath, chi.URLParam(r, "cv"), &cv)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "cv", Err: err})
		return
	}

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AddComicChapterLink(w, r, code, cv)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// DeleteComicChapterLink operation middleware
func (siw *ServerInterfaceWrapper) DeleteComicChapterLink(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "code" -------------
	var code string

	err = runtime.BindStyledParameterWithLocation("simple", false, "code", runtime.ParamLocationPath, chi.URLParam(r, "code"), &code)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "code", Err: err})
		return
	}

	// ------------- Path parameter "cv" -------------
	var cv string

	err = runtime.BindStyledParameterWithLocation("simple", false, "cv", runtime.ParamLocationPath, chi.URLParam(r, "cv"), &cv)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "cv", Err: err})
		return
	}

	// ------------- Path parameter "websiteDomain" -------------
	var websiteDomain string

	err = runtime.BindStyledParameterWithLocation("simple", false, "websiteDomain", runtime.ParamLocationPath, chi.URLParam(r, "websiteDomain"), &websiteDomain)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "websiteDomain", Err: err})
		return
	}

	// ------------- Path parameter "relativeURL" -------------
	var relativeURL string

	err = runtime.BindStyledParameterWithLocation("simple", false, "relativeURL", runtime.ParamLocationPath, chi.URLParam(r, "relativeURL"), &relativeURL)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "relativeURL", Err: err})
		return
	}

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteComicChapterLink(w, r, code, cv, websiteDomain, relativeURL)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetComicChapterLink operation middleware
func (siw *ServerInterfaceWrapper) GetComicChapterLink(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "code" -------------
	var code string

	err = runtime.BindStyledParameterWithLocation("simple", false, "code", runtime.ParamLocationPath, chi.URLParam(r, "code"), &code)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "code", Err: err})
		return
	}

	// ------------- Path parameter "cv" -------------
	var cv string

	err = runtime.BindStyledParameterWithLocation("simple", false, "cv", runtime.ParamLocationPath, chi.URLParam(r, "cv"), &cv)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "cv", Err: err})
		return
	}

	// ------------- Path parameter "websiteDomain" -------------
	var websiteDomain string

	err = runtime.BindStyledParameterWithLocation("simple", false, "websiteDomain", runtime.ParamLocationPath, chi.URLParam(r, "websiteDomain"), &websiteDomain)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "websiteDomain", Err: err})
		return
	}

	// ------------- Path parameter "relativeURL" -------------
	var relativeURL string

	err = runtime.BindStyledParameterWithLocation("simple", false, "relativeURL", runtime.ParamLocationPath, chi.URLParam(r, "relativeURL"), &relativeURL)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "relativeURL", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetComicChapterLink(w, r, code, cv, websiteDomain, relativeURL)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// UpdateComicChapterLink operation middleware
func (siw *ServerInterfaceWrapper) UpdateComicChapterLink(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "code" -------------
	var code string

	err = runtime.BindStyledParameterWithLocation("simple", false, "code", runtime.ParamLocationPath, chi.URLParam(r, "code"), &code)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "code", Err: err})
		return
	}

	// ------------- Path parameter "cv" -------------
	var cv string

	err = runtime.BindStyledParameterWithLocation("simple", false, "cv", runtime.ParamLocationPath, chi.URLParam(r, "cv"), &cv)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "cv", Err: err})
		return
	}

	// ------------- Path parameter "websiteDomain" -------------
	var websiteDomain string

	err = runtime.BindStyledParameterWithLocation("simple", false, "websiteDomain", runtime.ParamLocationPath, chi.URLParam(r, "websiteDomain"), &websiteDomain)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "websiteDomain", Err: err})
		return
	}

	// ------------- Path parameter "relativeURL" -------------
	var relativeURL string

	err = runtime.BindStyledParameterWithLocation("simple", false, "relativeURL", runtime.ParamLocationPath, chi.URLParam(r, "relativeURL"), &relativeURL)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "relativeURL", Err: err})
		return
	}

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UpdateComicChapterLink(w, r, code, cv, websiteDomain, relativeURL)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// AddComicLink operation middleware
func (siw *ServerInterfaceWrapper) AddComicLink(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "code" -------------
	var code string

	err = runtime.BindStyledParameterWithLocation("simple", false, "code", runtime.ParamLocationPath, chi.URLParam(r, "code"), &code)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "code", Err: err})
		return
	}

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AddComicLink(w, r, code)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// DeleteComicLink operation middleware
func (siw *ServerInterfaceWrapper) DeleteComicLink(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "code" -------------
	var code string

	err = runtime.BindStyledParameterWithLocation("simple", false, "code", runtime.ParamLocationPath, chi.URLParam(r, "code"), &code)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "code", Err: err})
		return
	}

	// ------------- Path parameter "websiteDomain" -------------
	var websiteDomain string

	err = runtime.BindStyledParameterWithLocation("simple", false, "websiteDomain", runtime.ParamLocationPath, chi.URLParam(r, "websiteDomain"), &websiteDomain)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "websiteDomain", Err: err})
		return
	}

	// ------------- Path parameter "relativeURL" -------------
	var relativeURL string

	err = runtime.BindStyledParameterWithLocation("simple", false, "relativeURL", runtime.ParamLocationPath, chi.URLParam(r, "relativeURL"), &relativeURL)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "relativeURL", Err: err})
		return
	}

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteComicLink(w, r, code, websiteDomain, relativeURL)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetComicLink operation middleware
func (siw *ServerInterfaceWrapper) GetComicLink(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "code" -------------
	var code string

	err = runtime.BindStyledParameterWithLocation("simple", false, "code", runtime.ParamLocationPath, chi.URLParam(r, "code"), &code)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "code", Err: err})
		return
	}

	// ------------- Path parameter "websiteDomain" -------------
	var websiteDomain string

	err = runtime.BindStyledParameterWithLocation("simple", false, "websiteDomain", runtime.ParamLocationPath, chi.URLParam(r, "websiteDomain"), &websiteDomain)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "websiteDomain", Err: err})
		return
	}

	// ------------- Path parameter "relativeURL" -------------
	var relativeURL string

	err = runtime.BindStyledParameterWithLocation("simple", false, "relativeURL", runtime.ParamLocationPath, chi.URLParam(r, "relativeURL"), &relativeURL)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "relativeURL", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetComicLink(w, r, code, websiteDomain, relativeURL)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// UpdateComicLink operation middleware
func (siw *ServerInterfaceWrapper) UpdateComicLink(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "code" -------------
	var code string

	err = runtime.BindStyledParameterWithLocation("simple", false, "code", runtime.ParamLocationPath, chi.URLParam(r, "code"), &code)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "code", Err: err})
		return
	}

	// ------------- Path parameter "websiteDomain" -------------
	var websiteDomain string

	err = runtime.BindStyledParameterWithLocation("simple", false, "websiteDomain", runtime.ParamLocationPath, chi.URLParam(r, "websiteDomain"), &websiteDomain)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "websiteDomain", Err: err})
		return
	}

	// ------------- Path parameter "relativeURL" -------------
	var relativeURL string

	err = runtime.BindStyledParameterWithLocation("simple", false, "relativeURL", runtime.ParamLocationPath, chi.URLParam(r, "relativeURL"), &relativeURL)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "relativeURL", Err: err})
		return
	}

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UpdateComicLink(w, r, code, websiteDomain, relativeURL)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// ListLanguage operation middleware
func (siw *ServerInterfaceWrapper) ListLanguage(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params ListLanguageParams

	// ------------- Optional query parameter "page" -------------

	err = runtime.BindQueryParameter("form", true, false, "page", r.URL.Query(), &params.Page)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "page", Err: err})
		return
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "limit", Err: err})
		return
	}

	// ------------- Optional query parameter "order_by" -------------

	err = runtime.BindQueryParameter("form", true, false, "order_by", r.URL.Query(), &params.OrderBy)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "order_by", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListLanguage(w, r, params)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// AddLanguage operation middleware
func (siw *ServerInterfaceWrapper) AddLanguage(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AddLanguage(w, r)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// DeleteLanguage operation middleware
func (siw *ServerInterfaceWrapper) DeleteLanguage(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "ietf" -------------
	var ietf string

	err = runtime.BindStyledParameterWithLocation("simple", false, "ietf", runtime.ParamLocationPath, chi.URLParam(r, "ietf"), &ietf)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "ietf", Err: err})
		return
	}

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteLanguage(w, r, ietf)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetLanguage operation middleware
func (siw *ServerInterfaceWrapper) GetLanguage(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "ietf" -------------
	var ietf string

	err = runtime.BindStyledParameterWithLocation("simple", false, "ietf", runtime.ParamLocationPath, chi.URLParam(r, "ietf"), &ietf)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "ietf", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetLanguage(w, r, ietf)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// UpdateLanguage operation middleware
func (siw *ServerInterfaceWrapper) UpdateLanguage(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "ietf" -------------
	var ietf string

	err = runtime.BindStyledParameterWithLocation("simple", false, "ietf", runtime.ParamLocationPath, chi.URLParam(r, "ietf"), &ietf)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "ietf", Err: err})
		return
	}

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UpdateLanguage(w, r, ietf)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// ListLink operation middleware
func (siw *ServerInterfaceWrapper) ListLink(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params ListLinkParams

	// ------------- Optional query parameter "page" -------------

	err = runtime.BindQueryParameter("form", true, false, "page", r.URL.Query(), &params.Page)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "page", Err: err})
		return
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "limit", Err: err})
		return
	}

	// ------------- Optional query parameter "order_by" -------------

	err = runtime.BindQueryParameter("form", true, false, "order_by", r.URL.Query(), &params.OrderBy)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "order_by", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListLink(w, r, params)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// AddLink operation middleware
func (siw *ServerInterfaceWrapper) AddLink(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AddLink(w, r)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// DeleteLink operation middleware
func (siw *ServerInterfaceWrapper) DeleteLink(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "websiteDomain" -------------
	var websiteDomain string

	err = runtime.BindStyledParameterWithLocation("simple", false, "websiteDomain", runtime.ParamLocationPath, chi.URLParam(r, "websiteDomain"), &websiteDomain)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "websiteDomain", Err: err})
		return
	}

	// ------------- Path parameter "relativeURL" -------------
	var relativeURL string

	err = runtime.BindStyledParameterWithLocation("simple", false, "relativeURL", runtime.ParamLocationPath, chi.URLParam(r, "relativeURL"), &relativeURL)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "relativeURL", Err: err})
		return
	}

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteLink(w, r, websiteDomain, relativeURL)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetLink operation middleware
func (siw *ServerInterfaceWrapper) GetLink(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "websiteDomain" -------------
	var websiteDomain string

	err = runtime.BindStyledParameterWithLocation("simple", false, "websiteDomain", runtime.ParamLocationPath, chi.URLParam(r, "websiteDomain"), &websiteDomain)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "websiteDomain", Err: err})
		return
	}

	// ------------- Path parameter "relativeURL" -------------
	var relativeURL string

	err = runtime.BindStyledParameterWithLocation("simple", false, "relativeURL", runtime.ParamLocationPath, chi.URLParam(r, "relativeURL"), &relativeURL)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "relativeURL", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetLink(w, r, websiteDomain, relativeURL)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// UpdateLink operation middleware
func (siw *ServerInterfaceWrapper) UpdateLink(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "websiteDomain" -------------
	var websiteDomain string

	err = runtime.BindStyledParameterWithLocation("simple", false, "websiteDomain", runtime.ParamLocationPath, chi.URLParam(r, "websiteDomain"), &websiteDomain)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "websiteDomain", Err: err})
		return
	}

	// ------------- Path parameter "relativeURL" -------------
	var relativeURL string

	err = runtime.BindStyledParameterWithLocation("simple", false, "relativeURL", runtime.ParamLocationPath, chi.URLParam(r, "relativeURL"), &relativeURL)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "relativeURL", Err: err})
		return
	}

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UpdateLink(w, r, websiteDomain, relativeURL)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// AddLinkTLLanguage operation middleware
func (siw *ServerInterfaceWrapper) AddLinkTLLanguage(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "websiteDomain" -------------
	var websiteDomain string

	err = runtime.BindStyledParameterWithLocation("simple", false, "websiteDomain", runtime.ParamLocationPath, chi.URLParam(r, "websiteDomain"), &websiteDomain)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "websiteDomain", Err: err})
		return
	}

	// ------------- Path parameter "relativeURL" -------------
	var relativeURL string

	err = runtime.BindStyledParameterWithLocation("simple", false, "relativeURL", runtime.ParamLocationPath, chi.URLParam(r, "relativeURL"), &relativeURL)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "relativeURL", Err: err})
		return
	}

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AddLinkTLLanguage(w, r, websiteDomain, relativeURL)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// DeleteLinkTLLanguage operation middleware
func (siw *ServerInterfaceWrapper) DeleteLinkTLLanguage(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "websiteDomain" -------------
	var websiteDomain string

	err = runtime.BindStyledParameterWithLocation("simple", false, "websiteDomain", runtime.ParamLocationPath, chi.URLParam(r, "websiteDomain"), &websiteDomain)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "websiteDomain", Err: err})
		return
	}

	// ------------- Path parameter "relativeURL" -------------
	var relativeURL string

	err = runtime.BindStyledParameterWithLocation("simple", false, "relativeURL", runtime.ParamLocationPath, chi.URLParam(r, "relativeURL"), &relativeURL)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "relativeURL", Err: err})
		return
	}

	// ------------- Path parameter "ietf" -------------
	var ietf string

	err = runtime.BindStyledParameterWithLocation("simple", false, "ietf", runtime.ParamLocationPath, chi.URLParam(r, "ietf"), &ietf)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "ietf", Err: err})
		return
	}

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteLinkTLLanguage(w, r, websiteDomain, relativeURL, ietf)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetLinkTLLanguage operation middleware
func (siw *ServerInterfaceWrapper) GetLinkTLLanguage(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "websiteDomain" -------------
	var websiteDomain string

	err = runtime.BindStyledParameterWithLocation("simple", false, "websiteDomain", runtime.ParamLocationPath, chi.URLParam(r, "websiteDomain"), &websiteDomain)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "websiteDomain", Err: err})
		return
	}

	// ------------- Path parameter "relativeURL" -------------
	var relativeURL string

	err = runtime.BindStyledParameterWithLocation("simple", false, "relativeURL", runtime.ParamLocationPath, chi.URLParam(r, "relativeURL"), &relativeURL)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "relativeURL", Err: err})
		return
	}

	// ------------- Path parameter "ietf" -------------
	var ietf string

	err = runtime.BindStyledParameterWithLocation("simple", false, "ietf", runtime.ParamLocationPath, chi.URLParam(r, "ietf"), &ietf)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "ietf", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetLinkTLLanguage(w, r, websiteDomain, relativeURL, ietf)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// UpdateLinkTLLanguage operation middleware
func (siw *ServerInterfaceWrapper) UpdateLinkTLLanguage(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "websiteDomain" -------------
	var websiteDomain string

	err = runtime.BindStyledParameterWithLocation("simple", false, "websiteDomain", runtime.ParamLocationPath, chi.URLParam(r, "websiteDomain"), &websiteDomain)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "websiteDomain", Err: err})
		return
	}

	// ------------- Path parameter "relativeURL" -------------
	var relativeURL string

	err = runtime.BindStyledParameterWithLocation("simple", false, "relativeURL", runtime.ParamLocationPath, chi.URLParam(r, "relativeURL"), &relativeURL)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "relativeURL", Err: err})
		return
	}

	// ------------- Path parameter "ietf" -------------
	var ietf string

	err = runtime.BindStyledParameterWithLocation("simple", false, "ietf", runtime.ParamLocationPath, chi.URLParam(r, "ietf"), &ietf)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "ietf", Err: err})
		return
	}

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UpdateLinkTLLanguage(w, r, websiteDomain, relativeURL, ietf)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// ListWebsite operation middleware
func (siw *ServerInterfaceWrapper) ListWebsite(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params ListWebsiteParams

	// ------------- Optional query parameter "page" -------------

	err = runtime.BindQueryParameter("form", true, false, "page", r.URL.Query(), &params.Page)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "page", Err: err})
		return
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "limit", Err: err})
		return
	}

	// ------------- Optional query parameter "order_by" -------------

	err = runtime.BindQueryParameter("form", true, false, "order_by", r.URL.Query(), &params.OrderBy)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "order_by", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListWebsite(w, r, params)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// AddWebsite operation middleware
func (siw *ServerInterfaceWrapper) AddWebsite(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AddWebsite(w, r)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// DeleteWebsite operation middleware
func (siw *ServerInterfaceWrapper) DeleteWebsite(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "domain" -------------
	var domain string

	err = runtime.BindStyledParameterWithLocation("simple", false, "domain", runtime.ParamLocationPath, chi.URLParam(r, "domain"), &domain)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "domain", Err: err})
		return
	}

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteWebsite(w, r, domain)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetWebsite operation middleware
func (siw *ServerInterfaceWrapper) GetWebsite(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "domain" -------------
	var domain string

	err = runtime.BindStyledParameterWithLocation("simple", false, "domain", runtime.ParamLocationPath, chi.URLParam(r, "domain"), &domain)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "domain", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetWebsite(w, r, domain)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// UpdateWebsite operation middleware
func (siw *ServerInterfaceWrapper) UpdateWebsite(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "domain" -------------
	var domain string

	err = runtime.BindStyledParameterWithLocation("simple", false, "domain", runtime.ParamLocationPath, chi.URLParam(r, "domain"), &domain)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "domain", Err: err})
		return
	}

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UpdateWebsite(w, r, domain)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// AddWebsiteTLLanguage operation middleware
func (siw *ServerInterfaceWrapper) AddWebsiteTLLanguage(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "domain" -------------
	var domain string

	err = runtime.BindStyledParameterWithLocation("simple", false, "domain", runtime.ParamLocationPath, chi.URLParam(r, "domain"), &domain)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "domain", Err: err})
		return
	}

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AddWebsiteTLLanguage(w, r, domain)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// DeleteWebsiteTLLanguage operation middleware
func (siw *ServerInterfaceWrapper) DeleteWebsiteTLLanguage(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "domain" -------------
	var domain string

	err = runtime.BindStyledParameterWithLocation("simple", false, "domain", runtime.ParamLocationPath, chi.URLParam(r, "domain"), &domain)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "domain", Err: err})
		return
	}

	// ------------- Path parameter "ietf" -------------
	var ietf string

	err = runtime.BindStyledParameterWithLocation("simple", false, "ietf", runtime.ParamLocationPath, chi.URLParam(r, "ietf"), &ietf)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "ietf", Err: err})
		return
	}

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteWebsiteTLLanguage(w, r, domain, ietf)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetWebsiteTLLanguage operation middleware
func (siw *ServerInterfaceWrapper) GetWebsiteTLLanguage(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "domain" -------------
	var domain string

	err = runtime.BindStyledParameterWithLocation("simple", false, "domain", runtime.ParamLocationPath, chi.URLParam(r, "domain"), &domain)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "domain", Err: err})
		return
	}

	// ------------- Path parameter "ietf" -------------
	var ietf string

	err = runtime.BindStyledParameterWithLocation("simple", false, "ietf", runtime.ParamLocationPath, chi.URLParam(r, "ietf"), &ietf)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "ietf", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetWebsiteTLLanguage(w, r, domain, ietf)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// UpdateWebsiteTLLanguage operation middleware
func (siw *ServerInterfaceWrapper) UpdateWebsiteTLLanguage(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "domain" -------------
	var domain string

	err = runtime.BindStyledParameterWithLocation("simple", false, "domain", runtime.ParamLocationPath, chi.URLParam(r, "domain"), &domain)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "domain", Err: err})
		return
	}

	// ------------- Path parameter "ietf" -------------
	var ietf string

	err = runtime.BindStyledParameterWithLocation("simple", false, "ietf", runtime.ParamLocationPath, chi.URLParam(r, "ietf"), &ietf)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "ietf", Err: err})
		return
	}

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UpdateWebsiteTLLanguage(w, r, domain, ietf)
	}))

	for i := len(siw.HandlerMiddlewares) - 1; i >= 0; i-- {
		handler = siw.HandlerMiddlewares[i](handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

type UnescapedCookieParamError struct {
	ParamName string
	Err       error
}

func (e *UnescapedCookieParamError) Error() string {
	return fmt.Sprintf("error unescaping cookie parameter '%s'", e.ParamName)
}

func (e *UnescapedCookieParamError) Unwrap() error {
	return e.Err
}

type UnmarshalingParamError struct {
	ParamName string
	Err       error
}

func (e *UnmarshalingParamError) Error() string {
	return fmt.Sprintf("Error unmarshaling parameter %s as JSON: %s", e.ParamName, e.Err.Error())
}

func (e *UnmarshalingParamError) Unwrap() error {
	return e.Err
}

type RequiredParamError struct {
	ParamName string
}

func (e *RequiredParamError) Error() string {
	return fmt.Sprintf("Query argument %s is required, but not found", e.ParamName)
}

type RequiredHeaderError struct {
	ParamName string
	Err       error
}

func (e *RequiredHeaderError) Error() string {
	return fmt.Sprintf("Header parameter %s is required, but not found", e.ParamName)
}

func (e *RequiredHeaderError) Unwrap() error {
	return e.Err
}

type InvalidParamFormatError struct {
	ParamName string
	Err       error
}

func (e *InvalidParamFormatError) Error() string {
	return fmt.Sprintf("Invalid format for parameter %s: %s", e.ParamName, e.Err.Error())
}

func (e *InvalidParamFormatError) Unwrap() error {
	return e.Err
}

type TooManyValuesForParamError struct {
	ParamName string
	Count     int
}

func (e *TooManyValuesForParamError) Error() string {
	return fmt.Sprintf("Expected one value for %s, got %d", e.ParamName, e.Count)
}

// Handler creates http.Handler with routing matching OpenAPI spec.
func Handler(si ServerInterface) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{})
}

type ChiServerOptions struct {
	BaseURL          string
	BaseRouter       chi.Router
	Middlewares      []MiddlewareFunc
	ErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

// HandlerFromMux creates http.Handler with routing matching OpenAPI spec based on the provided mux.
func HandlerFromMux(si ServerInterface, r chi.Router) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{
		BaseRouter: r,
	})
}

func HandlerFromMuxWithBaseURL(si ServerInterface, r chi.Router, baseURL string) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{
		BaseURL:    baseURL,
		BaseRouter: r,
	})
}

// HandlerWithOptions creates http.Handler with additional options
func HandlerWithOptions(si ServerInterface, options ChiServerOptions) http.Handler {
	r := options.BaseRouter

	if r == nil {
		r = chi.NewRouter()
	}
	if options.ErrorHandlerFunc == nil {
		options.ErrorHandlerFunc = func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusBadRequest)
		}
	}
	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandlerFunc:   options.ErrorHandlerFunc,
	}

	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/comics", wrapper.ListComic)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/comics", wrapper.AddComic)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/comics/{code}", wrapper.DeleteComic)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/comics/{code}", wrapper.GetComic)
	})
	r.Group(func(r chi.Router) {
		r.Patch(options.BaseURL+"/comics/{code}", wrapper.UpdateComic)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/comics/{code}/chapters", wrapper.ListComicChapter)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/comics/{code}/chapters", wrapper.AddComicChapter)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/comics/{code}/chapters/{cv}", wrapper.DeleteComicChapter)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/comics/{code}/chapters/{cv}", wrapper.GetComicChapter)
	})
	r.Group(func(r chi.Router) {
		r.Patch(options.BaseURL+"/comics/{code}/chapters/{cv}", wrapper.UpdateComicChapter)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/comics/{code}/chapters/{cv}/links", wrapper.AddComicChapterLink)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/comics/{code}/chapters/{cv}/links/{websiteDomain}-{relativeURL}", wrapper.DeleteComicChapterLink)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/comics/{code}/chapters/{cv}/links/{websiteDomain}-{relativeURL}", wrapper.GetComicChapterLink)
	})
	r.Group(func(r chi.Router) {
		r.Patch(options.BaseURL+"/comics/{code}/chapters/{cv}/links/{websiteDomain}-{relativeURL}", wrapper.UpdateComicChapterLink)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/comics/{code}/links", wrapper.AddComicLink)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/comics/{code}/links/{websiteDomain}-{relativeURL}", wrapper.DeleteComicLink)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/comics/{code}/links/{websiteDomain}-{relativeURL}", wrapper.GetComicLink)
	})
	r.Group(func(r chi.Router) {
		r.Patch(options.BaseURL+"/comics/{code}/links/{websiteDomain}-{relativeURL}", wrapper.UpdateComicLink)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/languages", wrapper.ListLanguage)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/languages", wrapper.AddLanguage)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/languages/{ietf}", wrapper.DeleteLanguage)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/languages/{ietf}", wrapper.GetLanguage)
	})
	r.Group(func(r chi.Router) {
		r.Patch(options.BaseURL+"/languages/{ietf}", wrapper.UpdateLanguage)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/links", wrapper.ListLink)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/links", wrapper.AddLink)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/links/{websiteDomain}-{relativeURL}", wrapper.DeleteLink)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/links/{websiteDomain}-{relativeURL}", wrapper.GetLink)
	})
	r.Group(func(r chi.Router) {
		r.Patch(options.BaseURL+"/links/{websiteDomain}-{relativeURL}", wrapper.UpdateLink)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/links/{websiteDomain}-{relativeURL}/tl-languages", wrapper.AddLinkTLLanguage)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/links/{websiteDomain}-{relativeURL}/tl-languages/{ietf}", wrapper.DeleteLinkTLLanguage)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/links/{websiteDomain}-{relativeURL}/tl-languages/{ietf}", wrapper.GetLinkTLLanguage)
	})
	r.Group(func(r chi.Router) {
		r.Patch(options.BaseURL+"/links/{websiteDomain}-{relativeURL}/tl-languages/{ietf}", wrapper.UpdateLinkTLLanguage)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/websites", wrapper.ListWebsite)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/websites", wrapper.AddWebsite)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/websites/{domain}", wrapper.DeleteWebsite)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/websites/{domain}", wrapper.GetWebsite)
	})
	r.Group(func(r chi.Router) {
		r.Patch(options.BaseURL+"/websites/{domain}", wrapper.UpdateWebsite)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/websites/{domain}/tl-languages", wrapper.AddWebsiteTLLanguage)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/websites/{domain}/tl-languages/{ietf}", wrapper.DeleteWebsiteTLLanguage)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/websites/{domain}/tl-languages/{ietf}", wrapper.GetWebsiteTLLanguage)
	})
	r.Group(func(r chi.Router) {
		r.Patch(options.BaseURL+"/websites/{domain}/tl-languages/{ietf}", wrapper.UpdateWebsiteTLLanguage)
	})

	return r
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
